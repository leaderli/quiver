{
  "title": "尾递归",
  "cells": [
    {
      "type": "text",
      "data": "<div><b style=\"font-size: 14px;\"><font face=\"Menlo\">尾调用优化</font></b></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">我们知道，函数调用会在内存形成一个\"调用记录\"，又称\"调用帧\"(callframe)，保存调用位置和内部变量等信</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">所有的调用记录，就形成一个<font color=\"#011993\">调用栈</font>(callstack)</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\"><img src=\"quiver-image-url/A9FDC4B63605AA522BC400F788FA57CB.jpg\" width=\"830\" height=\"256\"><br></span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</span></font></div>"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "function f(){\n    let m=1\n    let n=2\n    return g(m+n)\n}\n//等同于\nfunction f(){\n    return g(3)\n}\n//等同于\ng(3)"
    },
    {
      "type": "text",
      "data": "<div></div><div><span style=\"font-size: 14px; font-family: Menlo;\">上面代码中，如果函数g不是尾调用，函数蹴需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之</span><br></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">后，函数僦结束了，所以执行到最后一步，完全可以删除f()的调用记录，只保留g(3)的调用记录。</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">这就叫做\"尾调用优化\"(Tailcalloptimization)，即只保留内层函数的调用记录。如果所有函数都是尾调用，那</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是\"尾调用优化\"的意义。</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\"><br></span></font></div><div style=\"font-size: 15px;\"><font face=\"Menlo\"><span style=\"font-size: 16px;\"><b>尾递归</b></span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生栈溢出(stackoverflow)错误。但对</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">于尾递归来说，由于只存在一个调用记录，所以永远不会发生\"栈溢出\"错误。</span></font></div><div></div>"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "function factorial(n,total){\n    if( n===1) return total;\n    return factorial(n-1, n* total)\n}\n\nfactorial(5,1)//120"
    },
    {
      "type": "text",
      "data": "<div><span style=\"font-size: 14px; font-family: Menlo;\">上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度O(n)。</span><br></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">如果改写成尾递归，只保留一个调用记录，复杂度0(1)。</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\"><img src=\"quiver-image-url/690BD6AA5079FAA4AB6DE718352FE437.jpg\" width=\"230\" height=\"220\"><br></span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">由此可见，\"尾调用优化\"对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">一冫欠明确规定，所有ECMAScript的实现，都必须部署\"尾调用优化\"。这就是说，在ES6中，只要亻吏用尾递归，就</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">不会发生栈溢出，相对节省内存。</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\"><br></span></font></div><div style=\"font-size: 15px;\"><font face=\"Menlo\"><span style=\"font-size: 16px;\"><b>递归函数的改写</b></span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">量改写成函数的参数。比如上面的例子，阶乘函数factorial需要用到一个中间变量total，那就把这个中间变量改</span></font></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和</span></font><span style=\"font-size: 14px; font-family: Menlo;\">1？</span></div><div><font face=\"Menlo\"><span style=\"font-size: 14px;\">两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</span></font></div>"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "function tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nfunction factorial(n) {\n  return tailFactorial(n, 1);\n}\n\nfactorial(5) // 120"
    }
  ]
}